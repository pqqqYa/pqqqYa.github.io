---
layout: post
title: C语言进阶学习笔记
subtitle: 数据结构阶段
date: 2024-10-23 15:21:00
author: pqqqYa
header-img: img/post/2024-05-29-计算机网络基础学习笔记-bg.jpg
catalog: true
tags:
  - 笔记
  - C
  - Cpp
  - 数据结构
---

  

> 文章为王道C语言督学训练营02.中级阶段（数据结构算法题实战）网课笔记整理。
  

# 9. 数据结构概述


## 9.1 逻辑结构与存储结构

对比

* 逻辑结构：逻辑元素之间的逻辑关系（抽象的，对人友好的）
* 存储结构：数据结构在计算机中的表示（具体的，对计算机友好的）

逻辑结构

![数据结构的分类](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/1.png)


存储结构：任何存储结构都是用顺序存储或者链式存储来实现。


![顺序存储与链式存储](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/2.png)



链式存储的C语言实现

~~~cpp
Typdef struct Lnode{
	ElemType data;
	struct Lnode *next;
}Lnode,*LinkList;
Lnode *L;
L=(LinkList)malloc(sizeof(Lnode));
A->next=B;B->next=C
~~~


## 9.2 算法

算法：对特定问题求解步骤的描述（有穷、确定、可行、输入、输出）

## 9.3 时间复杂度

时间复杂度：算法中所有语句的频度（执行次数）之和，记为$T(n)=O(f(n))$，其中n是问题的规模，f(n)是问题规模n的某个函数。

常见时间复杂度（最高阶数越小，说明算法的时间性越好）

$$O(1)<O(\log_{2}{n})<O(n)<O(n\log_{2}{n})<O(n^2)<O(n^3)<O(2^n)<O(n!)$$

时间复杂度的计算忽略高阶项系数和低阶项

## 9.4 空间复杂度

空间复杂度$S(n)$指算法运行过程中所使用的辅助空间的大小。记为：$S(n)=O(f(n))$

* 除了需要存储算法本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。（n个元素数组排序，不需要额外的空间，空间复杂度就是$O(1)$）
* 若输入数据所占空间只取决于问题本身，和算法无关，这样只需分析该算法在实现时所需的辅助单元即可。
* 算法原地工作是指算法所需的辅助空间是常量，即$O(1)$。

# 10. 线性表的顺序存储

## 10.1 线性表

定义：

* 由n(n≥0)个相同类型的元素组成的有序集合。
* 顺序表在逻辑上相邻的两个元素在物理上也是相邻的
* 线性表是逻辑结构，是独立于存储结构。

特点：

* 表中元素的个数是有限的。
* 表中元素的数据类型都相同。意味着每一个元素占用相大小的空间
* 表中元素具有逻辑上的顺序性，在序列中各元素排序有先后顺序

顺序表的**优点**：

* 可以随机存取(根据表头元素地址和元素序号)表中任意一个元素。
* 存储密度高，每个结点只存储数据元素。

顺序表的**缺点**：

* 插入和删除操作需要移动大量元素。
* 线性表变化较大时，难以确定存储空间的容量。
* 存储分配需要一整段连续的存储空间，不够灵活。



静态分配数组内存大小

~~~cpp
#define Maxsize 50          //定义线性表的长度
typedef struct{
	ElemType data[MaxSize]; //顺序表的元素
	int len;                //顺序表的当前长度
}SqList;                    //顺序表的类型定义
~~~

动态分配数组内存大小（考试一般不用）

~~~cpp
#define InitSize 100    //表长度的初始定义
typedef struct{
	ElemType *data;     //指示动态分配数组的指针
	int MaxSize,length; //数组的最大容量和当前个数
}SeqList;               //动态分配数组顺序表的类型定义

//c的初始动态分配语句为：
L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);
~~~



## 10.2 顺序表的初始化及插入操作

### 10.2.1顺序表插入操作

~~~cpp
//判断插入位置i是否合法(满足1≤i≤len+1)
//判断存储空间是否已满(即插入x后是否会超出数组长度)
for(int j=L.len;j>=i;j--)  //将最后一个元素到第i个元素依次后移一位
{
	L.data[j]=L.data[j-1];
}
L.data[i-1]=x;             //空出的位置i处放入x
L.len++;                   //线性表长度加1
~~~


### 10.2.2 顺序表插入操作的时间复杂度分析

* 最好情况：在表尾插入元素，不需要移动元素，时间复杂度为O(1)。
* 最坏情况：在表头插入元素，所有元素依次后移，时间复杂度为O(n)。
* 平均情况：在插入位置概率均等的情况下，平均移动元素的次数为n/2，时间复杂度为O(n)。

### 10.2.3顺序表的初始化及插入实例

~~~cpp
#include <stdio.h>  
#define MaxSize 50  
typedef int ElemType;//让顺序表存储其他类型元素时可以快速完成代码修改  
typedef struct  
{  
    ElemType data[MaxSize];  
    int length;//当前顺序表元素数量  
}SqList;  
  
bool ListInsert(SqList &L,int position,ElemType element)//顺序表的插入，这里L会改变，所以使用取地址符  
{  
    if(position<1||position>L.length+1)//判断插入位置position是否合法  
    {  
        return false;  
    }  
    if(L.length>=MaxSize)//判断顺序表是否已满  
    {  
        return false;  
    }  
    for(int i = L.length;i>=position;i--)//从最后一个元素开始，依次向后移动，直到position位置为空  
    {  
        L.data[i] = L.data[i-1];  
    }  
    L.data[position-1] = element;//插入元素element到position位置  
    L.length++;//顺序表长度加一  
    return true;  
}  
  
void PrintList(SqList L)//打印顺序表  
{  
    for(int i = 0;i<L.length;i++)  
    {  
        printf("%3d ",L.data[i]);//为了打印到同一行  
    }  
}  
  
int main()  
{  
    SqList L;//定义一个顺序表  
    bool ret;//ret用来装函数的返回值  
    L.data[0] = 1;  
    L.data[1] = 2;  
    L.data[2] = 3;//放置元素  
    L.length = 3;//设置长度  
    ret=ListInsert(L,2,60);  
    if(ret)  
    {  
        printf("insert SqList success\n");  
    }  
    else  
    {  
        printf("insert SqList failed\n");  
    }  
    PrintList(L);//打印顺序表  
    return 0;  
}
//输出结果
//insert SqList success
//  1  60   2   3
~~~


## 10.3 顺序表的删除

### 10.3.1 顺序表元素删除操作的时间复杂度分析

* 最好情况：删除表尾元素，不需要移动元素，时间复杂度为O(1)。
* 最坏情况：删除表头元素，之后的所有元素依次前移，时间复杂度为0(n)。
* 平均情况:在删除位置概率均等的情况下，平均移动元素的次数为(n-1)/2时间复杂度为O(n)。

### 10.3.2 顺序表删除操作
~~~cpp
//判断删除位置i是否合法(满足1≤i≤len)
e=L.data[i-1];             //将被删除的元素赋值给e
for(int j=i-1;j<L.len;j++)   //将删除位置后的元素依次前移
{
	L.data[j]=L.data[j+1]; 
}
L.len--;                   //线性表长度减1
~~~

### 10.3.3 顺序表删除操作实例

~~~cpp
#include <stdio.h>  
#define MaxSize 50  
typedef int ElemType;//让顺序表存储其他类型元素时可以快速完成代码修改  
typedef struct  
{  
    ElemType data[MaxSize];  
    int length;//当前顺序表元素数量  
}SqList;  

//顺序表元素的删除，这里L和del都会改变，所以使用取地址符  
bool ListDelete(SqList &L,int position,ElemType &del)  
{  
    if(position<1||position>L.length)//判断删除位置position是否合法  
    {  
        return false;  
    }  
    del = L.data[position-1];//将删除的元素存入del中  
    for(int i = position-1;i<L.length;i++)//从position位置开始，依次向前移动，直到最后一个元素  
    {  
        L.data[i] = L.data[i+1];  
    }  
    L.length--;//顺序表长度减一  
    return true;  
}  
  
void PrintList(SqList L)//打印顺序表  
{  
    for(int i = 0;i<L.length;i++)  
    {  
        printf("%3d ",L.data[i]);//为了打印到同一行  
    }  
    printf("\n");  
}  
  
int main()  
{  
    SqList L;//定义一个顺序表  
    bool ret;//ret用来装函数的返回值  
    L.data[0] = 1;  
    L.data[1] = 2;  
    L.data[2] = 3;//放置元素  
    L.length = 3;//设置长度  
    PrintList(L);//打印顺序表  
    ElemType del;//删除的元素存入del中  
    ret=ListDelete(L,2,del);  
    if(ret)  
    {  
        printf("delete element = %d success\n",del);  
    }  
    else  
    {  
        printf("delete element failed\n");  
    }  
    PrintList(L);//打印顺序表  
    printf("%d\n",del);  
    return 0;  
}
~~~

## 10.4 顺序表的查找

~~~cpp
#include <stdio.h>  
#define MaxSize 50  
typedef int ElemType;//让顺序表存储其他类型元素时可以快速完成代码修改  
typedef struct  
{  
    ElemType data[MaxSize];  
    int length;//当前顺序表元素数量  
}SqList;  
  
//顺序表元素的查找  
int LocateElem(SqList L,ElemType element)  
{  
    for(int i = 0;i<L.length;i++)  
    {  
        if(L.data[i]==element)  
        {  
            return i+1;//返回元素位置  
        }  
    }  
    return 0;//返回0表示没有找到  
}  
  
int main()  
{  
    SqList L;//定义一个顺序表  
    bool ret;//ret用来装函数的返回值  
    L.data[0] = 1;  
    L.data[1] = 2;  
    L.data[2] = 3;//放置元素  
    L.length = 3;//设置长度  
    int pos;//存储查找的元素位置  
    pos=LocateElem(L,3);  
    if(pos)  
    {  
        printf("The element was found at the %dth position\n",pos);  
    }else  
    {  
        printf("No such element \n");  
    }  
    return 0;  
}
~~~

# 11 线性表的链式存储

## 11.1 线性表的链式存储

* 线性表的链式存储简称链表
* 逻辑上相邻的两个元素在物理位置上不相邻

单链表节点的定义

~~~cpp
typedef struct LNode{    //单链表结点类型
	ElemType data;       //数据域
	struct LNode *next;  //指针域
}LNode,*LinkList;
~~~

* `typedef struct LNode`中的`LNode`不能省略，因为在结构体的内部还需要使用它来定义指针变量`next`
* 表尾结点的指针域为`NULL`
* 可以添加头结点（考研基本都考的带头结点的题）
* 头结点：在单链表第一个结点之前附加的一个结点，为了操作上的方便
* 头指针：链表中第一个结点的存储位置，用来标识单链表

单链表的**优点**

* 插入和删除操作不需要移动元素，只需要修改指针。
* 不需要大量的连续存储空间。

单链表的**缺点**

* 单链表附加指针域，也存在浪费存储空间的缺点。（没有全部拿来存储数据）
* 查找操作时需要从表头开始遍历，依次查找，不能随机存取，

## 11.2 线性表的创建及插入结点

### 11.2.1 头插法新建链表实例


![头插法新建链表流程图](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/3.png)


~~~cpp
#include <stdio.h>  
#include <stdlib.h>  

typedef int ElemType;  
typedef struct LNode  
{  
    ElemType data;  
    struct LNode* next;  
}LNode,*LinkList;  
//LNode*是结构体指针，和LinkList是等价的  
void list_head_insert(LNode* &L)  
{  
    L = (LinkList)malloc(sizeof(LNode));//申请头结点空间，头指针指向结点（malloc函数返回地址值并赋值给L）  
    L->next = NULL;  
    L->data = NULL;  
    ElemType x;  
    scanf("%d",&x);  
    LNode * s;//用来指向申请的新结点  
    while(x!=9999)  
    {  
        s=(LNode*)malloc(sizeof(LNode));  
        s->data = x;  
        s->next = L->next;//s的next指向原本第一个结点的next  
        L->next = s;//头结点的next指向s，s就成为了第一个结点  
        scanf("%d",&x);  
    }  
}  
  
void print_list(LinkList L)  
{  
    L = L->next;//L指向第一个结点  
    while(L!=NULL)  
    {  
        printf("%3d",L->data);  
        L=L->next;  
    }  
}  
  
int main(){  
    LinkList L;//L是链表头指针，结构体指针类型，大小的8个字节  
    list_head_insert(L);//输入数据可以为3 4 5 6 7 9999，头插法新建链表  
    print_list(L);  
    return 0;  
  
}
~~~

###  11.2.2 尾插法新建链表实例


![尾插法新建链表流程图](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/4.png)



~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
  
typedef int ElemType;  
typedef struct LNode  
{  
    ElemType data;  
    struct LNode* next;  
}LNode,*LinkList;  
//LNode*是结构体指针，和LinkList是等价的  
void list_tail_insert(LNode* &L)  
{  
    L = (LinkList)malloc(sizeof(LNode));//申请头结点空间，头指针指向结点（malloc函数返回地址值并赋值给L）  
    L->next = NULL;  
    L->data = NULL;  
    ElemType x;  
    scanf("%d",&x);  
    LNode * s , *r=L;//s用来指向申请的新结点,r始终指向链表尾部的结点  
    while(x!=9999)  
    {  
        s=(LNode*)malloc(sizeof(LNode));//为新结点申请空间  
        s->data = x;  
        s->next = NULL;  
        r->next = s;//r始终指向尾结点  
        r=s;//r指向新的尾部  
        scanf("%d",&x);  
    }  
}  
  
void print_list(LinkList L)  
{  
    L = L->next;//L指向第一个结点  
    while(L!=NULL)  
    {  
        printf("%3d",L->data);  
        L=L->next;  
    }  
}  
  
int main(){  
    LinkList L;//L是链表头指针，结构体指针类型，大小的8个字节  
    list_tail_insert(L);//输入数据可以为3 4 5 6 7 9999，尾插法新建链表  
    print_list(L);  
    return 0;  
  
}
~~~




##  11.3 线性表的查找操作

### 11.3.1 线性表按序号查找结点值

~~~cpp
//寻找第i个元素
LNode *p=L->next;
int j=1;
while(p&&j<i)
{
	p=p->next;//指针变量存储下一个结点的地址（称为成为下一个结点）
	j++;
}
return p;
~~~

### 11.3.2 线性表按值查找结点地址

~~~cpp
LNode *p=L->next;
while(p!=NULL&&p->data!=e){
	p=p->next;
}
return p;
~~~

### 11.3.3 线性表2种查找方式实例

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
  
typedef int ElemType;  
typedef struct LNode  
{  
    ElemType data;  
    struct LNode* next;  
}LNode,*LinkList;  
  
void list_tail_insert(LNode* &L)  
{  
    L = (LinkList)malloc(sizeof(LNode));  
    L->next = NULL;  
    L->data = NULL;  
    ElemType x;  
    scanf("%d",&x);  
    LNode * s , *r=L;  
    while(x!=9999)  
    {  
        s=(LNode*)malloc(sizeof(LNode));  
        s->data = x;  
        s->next = NULL;  
        r->next = s;  
        r=s;  
        scanf("%d",&x);  
    }  
}  
//按位置查找  
LinkList GetElem(LinkList L,int SearchPos)  
{  
    int i = 0;  
    if(SearchPos<0)  
    {  
        return NULL;  
    }  
    while(L&&i<SearchPos)  
    {  
        L = L->next;  
        i++;  
    }  
    return L;  
}  
  
//按值查找  
LinkList LocateElem(LinkList L,ElemType SearchElem)  
{  
    L = L->next;  
    while(L)  
    {  
        if(L->data == SearchElem)  
        {  
            return L;  
        }  
        L = L->next;  
    }  
    return NULL;  
}  
  
  
int main(){  
    LinkList L,search;//L是链表头指针，search是查找的结点  
    list_tail_insert(L);  
    search = GetElem(L,2);  //按位置查找
    if(search!=NULL)  
    {  
        printf("Success in searching by number\n");  
        printf("%d\n",search->data);  
    }else  
    {  
        printf("Fail in searching by number\n");  
    }  
    search = LocateElem(L,1);  //按值查找
    if(search!=NULL)  
    {  
        printf("Success in searching by number\n");  
        printf("%p\n",search);  
    }else  
    {  
        printf("Fail in searching by number\n");  
    }  
    return 0;  
  
}
~~~

## 11.4 线性表的插入操作

### 11.4.1 线性表插入


![单链表向第i个位置插入元素流程图](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/5.png)



~~~cpp
//创建新节点q
q=(LNode*)malloc(sizeof(LNode))
q->data=x;
//在p的后面插入新节点q
q->next = p->next;
p->next = q;
//让q成为新的表尾
p->next = q;
q->next = NULL;
~~~

### 11.4.2 线性表插入操作实例

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
  
typedef int ElemType;  
typedef struct LNode  
{  
    ElemType data;  
    struct LNode* next;  
}LNode,*LinkList;  
  
void list_tail_insert(LNode* &L)  
{  
    L = (LinkList)malloc(sizeof(LNode));  
    L->next = NULL;  
    L->data = NULL;  
    ElemType x;  
    scanf("%d",&x);  
    LNode * s , *r=L;  
    while(x!=9999)  
    {  
        s=(LNode*)malloc(sizeof(LNode));  
        s->data = x;  
        s->next = NULL;  
        r->next = s;  
        r=s;  
        scanf("%d",&x);  
    }  
}  
  
LinkList GetElem(LinkList L,int SearchPos)  
{  
    int i = 0;  
    if(SearchPos<0)  
    {  
        return NULL;  
    }  
    while(L&&i<SearchPos)  
    {  
        L = L->next;  
        i++;  
    }  
    return L;  
}  
  
void print_list(LinkList L)  
{  
    L = L->next;//L指向第一个结点  
    while(L!=NULL)  
    {  
        printf("%3d",L->data);  
        L=L->next;  
    }  
    printf("\n");  
}  
bool ListFrontInsert(LinkList L,int InsertPos,ElemType e)  
{  
    LinkList p = GetElem(L,InsertPos-1);  
    if(p==NULL)  
    {  
        return false;  
    }  
    LinkList q=(LNode*)malloc(sizeof(LNode));  
    q->data = e;  
    q->next = p->next;  
    p->next = q;  
    return true;  
}  
  
int main(){  
    LinkList L,search;//L是链表头指针，search是查找的结点  
    list_tail_insert(L);  
    print_list(L);  
    ListFrontInsert(L,2,99);  
    print_list(L);  
    return 0;  
  
}
~~~



## 11.5 线性表的删除操作

### 11.5.1 线性表结点删除

头结点是不能删除的。

~~~cpp
p=GetElem(L,i-1);//查找删除位置的前驱节点
q = p->next;//q指向需要被删除的元素
p->next = q->next;//让被删除元素的前一个元素next指向被删除元素的后一个元素，实现断链
free(q);//释放被删除元素
~~~

### 11.5.2 线性表结点删除实例

![线性表结点删除操作流程图](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/6.png)

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
  
typedef int ElemType;  
typedef struct LNode  
{  
    ElemType data;  
    struct LNode* next;  
}LNode,*LinkList;  
  
void list_tail_insert(LNode* &L)  
{  
    L = (LinkList)malloc(sizeof(LNode));  
    L->next = NULL;  
    L->data = NULL;  
    ElemType x;  
    scanf("%d",&x);  
    LNode * s , *r=L;  
    while(x!=9999)  
    {  
        s=(LNode*)malloc(sizeof(LNode));  
        s->data = x;  
        s->next = NULL;  
        r->next = s;  
        r=s;  
        scanf("%d",&x);  
    }  
}  
  
LinkList GetElem(LinkList L,int SearchPos)  
{  
    int i = 0;  
    if(SearchPos<0)  
    {  
        return NULL;  
    }  
    while(L&&i<SearchPos)  
    {  
        L = L->next;  
        i++;  
    }  
    return L;  
}  
  
void print_list(LinkList L)  
{  
    L = L->next;//L指向第一个结点  
    while(L!=NULL)  
    {  
        printf("%3d",L->data);  
        L=L->next;  
    }  
    printf("\n");  
}  
  
bool ListFrontDelete(LinkList &L,int DeletePos)  
{  
    LNode * p = GetElem(L,DeletePos-1);//查找第SearchPos-1个结点  
    if(p==NULL)  
    {  
        return false;  
    }  
    LNode * q = p->next;  
    p ->next= q->next;  
    free(q);  
    return true;  
}  
  
int main(){  
    LinkList L,search;//L是链表头指针，search是查找的结点  
    list_tail_insert(L);  
    print_list(L);  
    bool flag = ListFrontDelete(L,2);  
    if(flag)  
    {  
        printf("Delete success\n");  
        print_list(L);  
    }  
    else  
    {  
        printf("Delete success\n");  
    }  
  
    return 0;  
  
}
~~~

## 11.6 考研真题实战

### 11.6.1 真题实例

![链表408真题](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/7.png)

### 11.6.2 题目分析

* 不再去malloc会随着n的增大而增大的空间，即可实现时间复杂度为O(1)
* 时间上尽可能高效 = 时间复杂度尽可能的低
* 找到链表的**中间结点**，前面一半是链表L，将链表的后半部分给一个新的头结点 L2，然后将链表 L2 进行**原地逆置**，然后再将L和 L2 链表进行合并

1. 找到链表的中间结点
	* 双指针法2个指针，`pcur`指针每次走2步，`ppre`指针每次走1步，这样`pcur`指针走到最后的时候`ppre`指针正好在中间
	* 结点个数的奇偶并不影响最终的结果
2. 后一半的链表设置为L2，让L2原地逆置
	* 需要3指针`r`，`s`，`t`，分别指向前三个结点
	* `s`中的next指向`r`指向的结点，`r`，`s`，`t`再向后移动一个结点
1. 将L和L2链表合并，合并时轮流放入一个结点
	* 需要3指针`pcur`，`p`，`q`，分别指向新链表尾，L待放入结点，L2待放入结点
	* 循环放入，直到全部放完

### 11.6.3 真题解题代码

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
  
typedef int ElemType;  
typedef struct NODE  
{  
    int data;  
    struct NODE* next;  
}NODE;  
  
void list_tail_insert(NODE* &L)  
{  
    L = (NODE *)malloc(sizeof(NODE));  
    L->next = NULL;  
    L->data = NULL;  
    ElemType x;  
    scanf("%d",&x);  
    NODE * s , *r=L;  
    while(x!=9999)  
    {  
        s=(NODE*)malloc(sizeof(NODE));  
        s->data = x;  
        s->next = NULL;  
        r->next = s;  
        r=s;  
        scanf("%d",&x);  
    }  
}  
  
void print_list(NODE * L)  
{  
    L = L->next;//L指向第一个结点  
    while(L!=NULL)  
    {  
        printf("%3d",L->data);  
        L=L->next;  
    }  
    printf("\n");  
}  
  
//初试时不用写上面的尾插法创建链表和输出链表的函数  
  
void find_middle(NODE * L,NODE * &L2)  
{  
    L2 = (NODE *)malloc(sizeof(NODE));//第二条链表的头结点  
    NODE * pcur,* ppre;//双指针法  
    pcur = L->next;  
    ppre = L->next;  
    while(pcur!=NULL)  
    {  
        pcur = pcur->next;//第一个指针一次走2步  
        if(pcur == NULL)  
        {  
            break;  
        }  
        pcur = pcur->next;  
        if(pcur==NULL)//为了是偶数个的时候，pcur指向最后一个结点，ppre不再移动  
        {  
            break;  
        }  
        ppre = ppre->next;//第二个指针一次走1步  
    }  
    L2->next = ppre->next;//第二条链表的头结点指向中间结点  
    ppre->next = NULL;//把L切掉后半段，第一条链表的尾结点指向NULL  
}  
void reverse(NODE * &L)  
{  
    NODE *r,*s,*t;  
    r = L->next;  
    if(r==NULL)  
    {  
        return;//链表为空没有结点，直接返回  
    }  
    s = r->next;  
    if(s==NULL)  
    {  
        return;//链表只有1个结点，直接返回  
    }  
    t = s->next;  
    while(t)  
    {  
        s->next = r;  
        r = s;//以下三句三个指针同时往后走一步  
        s = t;  
        t = t->next;  
    }  
    s->next = r;  
    L->next->next = NULL;//逆置后，原有链表第一个结点的next指向NULL  
    L->next = s;//s为逆置后链表的第一个结点，L->next指向s  
}  
  
void merge(NODE * L,NODE * L2)  
{  
    NODE * pcur,* p,* q;  
    pcur = L->next;//pcur指向“新链表”L的链表尾  
    p = pcur->next;//p用来遍历L链表  
    q = L2->next;//q用来遍历L2链表  
    while(p!=NULL&&q!=NULL)  
    {  
        pcur ->next = q;  
        q = q->next;//指向下一个结点  
        pcur = pcur->next;  
        pcur ->next = p;  
        p = p->next;  
        pcur = pcur->next;  
    }  
    //任何一个链表都可能剩余一个结点  
    if(p!=NULL)  
    {  
        pcur->next = p;  
    }  
    if(q!=NULL)  
    {  
        pcur->next = q;  
    }  
}  
  
int main(){  
    NODE * L,* L2=NULL;  
    list_tail_insert(L);  
    //寻找中间结点，并返回第二条链表  
    find_middle(L,L2);//只有一个结点的时候，L2为NULL  
    reverse(L2);  
    merge(L,L2);  
    free(L2);  
    print_list(L);  
    return 0;  
  
}
~~~

### 11.6.4 真题的时间复杂度分析

* `find_middle`函数有一个whlie循环，因为 pcur 每次移动两个结点，因此循环次数是n/2，忽略首项系数，所以时间复杂度是`O(n)`
* `reverse`函数只遍历了L2链表，遍历长度是 n2，时间复杂度为`O(n)`
* `merge`函数把链表“拆成”了2个的遍历长度为n/2的链表，while循环遍历次数为n/2，时间复杂度为`O(n)`
* 上面的3个函数总运行次数是1.5n，忽略首项系数，所以时间复杂度是`O(n)`

# 12. 栈与队列

## 12.1 栈

### 12.1.1 栈

* `stack`栈、堆栈、堆叠：先进先出（First In Last Out）
* `Top`栈顶：只允许在一端进行插入或删除操作的线性表，后来的元素作为栈顶
* `Bottom`栈底：第一个进入的元素

### 12.1.2 栈的顺序存储

栈是一个结构体，不是结构体指针

~~~cpp
typedef struct{
	Elemtype data[50];
	int top;
}SqStack;
SqStack S;
~~~

### 12.1.3 元素的出栈与入栈

* 注意对top的是先移动还是后移动
* `S.top=MaxSize-1`时是栈满

~~~cpp
S.top=-1//栈为空
S.data[++S.top]=4//元素的入栈
x=S.data[S.top--]//元素的出栈
~~~

### 12.1.4 栈的链式存储

链栈的实现与链表的实现一致，详见链表章节（几乎不考）

* 元素的入栈=链表头插法
* 元素的出栈=删除第一个元素
* `L->next == NULL`栈为空

### 12.1.5 栈的初始化、出入栈，读取栈顶元素的代码实例

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
  
#define MaxSize 50  //限定数组大小
typedef int ElemType;  
  
typedef struct {  
    ElemType data[MaxSize];//数组  
    int top;  
} SqStack;  
//初始化栈  
void InitStack(SqStack &S)  
{  
    S.top = -1;//代表栈为空  
}  
//判断栈是否为空  
bool StackEmpty(SqStack &S)  
{  
    if (S.top == -1)  
    {  
        return true;  
    }  
    else  
    {  
        return false;  
    }  
}  
//入栈  
bool Push(SqStack &S, int x)  
{  
    if (S.top == MaxSize - 1)//数组的大小不能改变，，避免越界  
    {  
        return false;  
    }  
    S.data[++S.top] = x;  
    return true;  
}  
//出栈  
bool Pop(SqStack &S, int &x)  
{  
    if (S.top == -1)  
    {  
        return false;  
    }  
    x = S.data[S.top--];//后减减，x=S.data[S.top];S.top=S.top-1;  
    return true;  
}  
//读取栈顶元素  
bool GetTop(SqStack &S, int &x)  
{  
    if (S.top == -1)//说明栈为空  
    {  
        return false;  
    }  
    x = S.data[S.top];  
    return true;  
}  
  
int main()  
{  
    SqStack S;//先进后出 FILO LIFO    bool flag;//用来判断操作是否成功  
    ElemType m;//用来存放拿出的元素  
    InitStack(S);//初始化  
    //判断栈是否为空  
    flag = StackEmpty(S);  
    if(flag)  
    {  
        printf("栈是空的\n");  
    }  
    //入栈，获取栈顶元素  
    Push(S,3);//入栈元素 3    Push(S,4);//入栈元素 4    Push(S,5);//入栈元素 5    flag=GetTop(S,m);//获取栈顶元素  
    if(flag)  
    {  
        printf("获取栈顶元素为 %dwn",m);  
    }  
    //出栈  
    flag=Pop(S,m);//弹出栈顶元素  
    if(flag)  
    {  
        printf("弹出元素为 %dwn",m);  
    }  
    return 0;  
}
~~~

## 12.2 队列

### 12.2.1 队列

* `Queue`队列，简称队，只允许在一端进行插入，而在表的另一端进行删除。First In First Out
* **入队**（进队）向队列中插入元素
* **出队**（离队）删除元素
* `Front`队头允许删除的一端，称之为队首
* `Rear`队尾允许插入的一端

### 12.2.2 队列的链式表示

* 队列的链式表示称为链队列
* 一个同时带有队头指针和队尾指针的单链表。
* 头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点

~~~cpp
typedef int ElemType,
typedef struct LinkNode{
	ElemType data;
	struct LinkNode *next;
}LinkNode;//链表结点的结构体
typedef struct{
	LinkNode *front,*rear;//链表头 链表尾
}LinkQueue;//先进先出
LinkQueue Q:
~~~

相当于原有的链表编写添加了链头链尾

### 12.2.3队列的链式表达

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
typedef int ElemType;  
typedef struct LinkNode{  
ElemType data;  
struct LinkNode *next;  
}LinkNode;  
typedef struct{  
    LinkNode *front,*rear;//链表头 链表尾  
}LinkQueue;//先进先出  

//初始化队列
void InitQueue(LinkQueue &Q)  
{  
    Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));//头和尾指向同一个结点  
    Q.front->next=NULL;//头结点的 next 指针为 NULL}  
}
//判断队列是否为空
bool IsEmpty(LinkQueue Q)  
{  
    if(Q.front==Q.rear)  
    {  
        return true;  
    }  
    else  
    {  
        return false;  
    }   
	// return Q.front==Q.rear;//一条代码也可以完成
}  
//入队，尾部插入法  
void EnQueue(LinkQueue &Q,ElemType x)  
{  
    LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));  
    s->data=x;s->next=NULL;  
    Q.rear->next=s;//rear 始终指向尾部  
    Q.rear=s;  
}  
//出队 头部删除法  
bool DeQueue(LinkQueue &Q,ElemType &x)  
{  
    if(Q.front==Q.rear)  
    {  
        return false;//队列为空  
    }  
    LinkNode *p=Q.front->next;//头结点什么都没存，所以头结点的下一个节点才有数据  
    x=p->data;  
    Q.front->next=p->next;//断链  
    if(Q.rear==p)//删除的是最后一个元素  
        Q.rear=Q.front;//队列置为空  
    free(p);  
    return true;  
}  
  
int main(){  
    LinkQueue Q;  
    bool ret;  
    ElemType element;//存储出队元素  
    InitQueue(Q);//初始化队列  
    EnQueue(Q,3);  
    EnQueue(Q,4);  
    EnQueue(Q,5);  
    EnQueue(Q,6);  
    EnQueue(Q,7);  
    ret=DeQueue(Q,element);  
    if(ret){  
        printf("Dequeue successful, element value is %d\n",element);  
    }  
    {  
        printf("Dequeue failed \n");  
    }  
    return 0;  
}
~~~

## 12.3 循环队列

### 12.3.1 循环队列

* **注意**循环队列存储的是`MaxSize-1`个元素，防止分不清为空或为满
* `Q.front == Q.rear`相同表示循环队列为空
* `(Q.front + 1) % MaxSize == Q.rear`表示循环队列队满
* `Q.rear`指向的是最后一个元素之后的位置
* 出队就是移除`Q.front`指向的元素，入队就是添加`Q.rear`指向的前一个元素

~~~cpp
#define MaxSize 5
typedef int ElemType;
typedef struct{
	ElemType data[MaxSize];//数组,存储MaxSize-1个元素
	int front,rear;//队列头 队列尾
}SqQueue;
SqQueue Q;
~~~

![循环队列流程](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/8.png)

### 12.3.2 循环队列的入队

~~~cpp
#define MaxSize 5
bool EnQueue(SqQueue &Q,ElemType x)
{
	if((Q.rear+1)%MaxSize==Q.front)//判浙是否队满
	{
		return false;
	}
	Q.data[Q.rear]=x;//放入元素
	Q.rear=(Q.rear+1)%MaxSize;//改变队尾标记
	return true;
}
~~~

### 12.3.3 循环队列的出队

~~~cpp
bool DeQueue(SqQueue &Q,ElemType &x)
{
	if(Q.rear==Q.front)
	{
		return false;
	}                         
	x=Q.data[Q.front];//先进先出
	Q.front=(Q.front+1)%MaxSize;
	return true,
}
~~~

### 12.3.4 循环队列的代码实现

~~~cpp
#include <stdio.h>  
#define MaxSize 5  
  
typedef int ElemType;  
  
typedef struct {  
    ElemType data[MaxSize];  
    int front, rear;  
} SqQueue;  
  
void InitQueue(SqQueue &Q)  
{  
    Q.front = Q.rear = 0;  
}  
  
bool isEmpty(SqQueue Q)  
{  
    if (Q.front == Q.rear)  
    {  
        return true;  
    }  
    else  
    {  
        return false;  
    }  
}  
bool EnQueue(SqQueue &Q, ElemType x)  
{  
    if ((Q.rear+1)%MaxSize == Q.front)  
    {  
        return false;  
    }  
    Q.data[Q.rear] = x;  
    Q.rear = (Q.rear+1)%MaxSize;  
    return true;  
}  
  
bool DeQueue(SqQueue &Q, ElemType &x)  
{  
    if (Q.front == Q.rear)  
    {  
        return false;  
    }  
    x = Q.data[Q.front];  
    Q.front = (Q.front+1)%MaxSize;  
    return true;  
}  
  
int main()  
{  
    SqQueue Q;  
    bool ret;//存储返回值  
    ElemType element;//存储出队元素  
    InitQueue(Q);  
    ret = isEmpty(Q);  
    if (ret)  
    {  
        printf("Queue is empty\n");  
    }  
    else  
    {  
        printf("Queue is not empty\n");  
    }  
    EnQueue(Q, 1);  
    EnQueue(Q, 2);  
    EnQueue(Q, 3);  
    ret = EnQueue(Q, 4);  
    if (ret)  
    {  
        printf("EnQueue success\n");  
    }else  
    {  
        printf("EnQueue failed\n");  
    }  
    ret = EnQueue(Q, 5);  
    if (ret)  
    {  
        printf("EnQueue success\n");  
    }else  
    {  
        printf("EnQueue failed\n");  
    }  
    ret = DeQueue(Q, element);  
    if (ret)  
    {  
        printf("DeQueue success, element = %d\n", element);  
    }else  
    {  
        printf("DeQueue failed\n");  
    }  
  
    return 0;  
}
~~~

## 12.4 考研真题实战

### 12.4.1 真题实例

![栈与队列408真题](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/9.png)

### 12.4.2 题目分析解题

* 使用链式存储结构
* 初始状态创建带有一个空闲结点的两段式单向循环链表（两段式指的是一段用来存放数据的data段和存放指针的next段），头指针front和尾指针rear均指向空闲结点。
* 判空条件是`front==rear`
* 判满条件是`front==rear->next`
* 注意题目所说只增加不减少，在链表填充满时申请新的空间，在链表还有空位时直接替换新的值到“空位”上，即出队无需像链表的删除一样释放空间，直接使用新值覆盖即可
### 12.4.3 题目代码实现

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
  
typedef int ElementType;  
typedef struct LNode  
{  
    ElementType data;  
    struct LNode *next;  
}LNode, *LinkList;  
  
bool EnQueue(LinkList &front, LinkList &rear, ElementType val)  
{  
    LinkList pnew;  
    if (rear->next == front)  
    {  
        //队列满，申请一个结点的空间，放人队列  
        pnew= (LinkList)malloc(sizeof(LNode));  
        rear->data = val;//把人队元素放人 rear 指向结点  
        rear->next= pnew;//放了一个结点，其相当于做了分割  
        pnew->next= front;  
        rear= pnew;  
    }  
    else  
    {  
        //如果队列不满，直接放值，让 rear 后移一个结点  
        rear->data = val;  
        rear= rear->next;  
    }  
}  
  
void DeQueue(LinkList &front, LinkList &rear)  
{  
    if(front==rear)  
    {  
        printf("Queue is empty\n");  
    }else  
    {  
        printf("Element is %d\n", front->data);  
        front = front->next;  
    }  
  
}  
//循环队列操作的总流程  
void CircleQueue(LinkList &front, LinkList &rear)  
{  
    //队列头和队列尾都指向一个结点，这是队列既是空的，也是满的  
    front=(LinkList)malloc(sizeof(LNode));  
    rear=front;  
    rear->next=front;//构造循环队列  
    //入队  
    EnQueue(front, rear,3);  
    EnQueue(front, rear,4);  
    //出队  
    DeQueue(front, rear);  
    DeQueue(front, rear);  
    DeQueue(front, rear);  
}  
  
int main()  
{  
    LinkList front, rear;  
    CircleQueue (front, rear);  
    return 0;  
}
~~~

# 13. 树

## 13.1 树


*  `Tree`树是n(n>0)个节点的有限集。
* 当n=0时，称为空树。
* 在任意一棵非空树中应满足:
	1. 有且仅有一个特定的称为根的结点。
	2. 当n>1时，其余节点可分为m(m>0)个互不相交的有限集T1,T2... Tm，其中每个集合本身又是一棵树，并且称为根的子树。
* 树作为一种逻辑结构，同时也是一种分层结构
	1. 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。
	2. 树中所有结点可以有零个或多个后继

![树的结构](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/10.png)

## 13.2 二叉树

* 二叉树是一种树形结构
* 每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点，度指的是结点的分叉的数量）
* 二又树的子树有左右之分，其次序不能任意颠倒。
* 与树相似，二又树也以递归的形式定义。二树是n(n≥0)个结点的有限集合
	1. 或者为空二又树，即n=0。
	2. 或者由一个根结点和两个五不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。

![二叉树的结构](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/11.png)

* 满二叉树：每一层的个数就是$2^{n-1}$个结点
* 完全二叉树：从左往右依次填充满了再填充下一层的二叉树

### 13.2.1 二叉树的顺序存储

![二叉树的顺序存储](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/12.png)

### 13.2.2二叉树的链式存储

![二叉树的链式存储](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/13.png)

~~~cpp
typedef char BiElemType,
typedef struct BiTNodef
	BiElemType data;       //数据段
	struct BiTNode *lchild://左指针
	struct BiTNode *rchild://右指针
}BiTNode,*BiTree,
~~~

### 13.2.3二叉树层次建树实例

使用辅助队列

1. 在元素放入二叉树前，先~~放入~~辅助队列（这里辅助队列的data段直接存放树的结点的地址值，因为这里不需要对元素进行操作）
2. `pcur`指针指向第一个放入的元素
3. 放入第二个元素，判断`pcur`指针指向的元素即第一个元素，左右结点是否为空，优先放入左节点
4. 当第一个元素放满，`pcur`指针指向第二个元素
5. 队列放入第四个元素，判断`pcur`指针指向的元素即第二个元素，左右结点是否为空，优先放入左节点
6. 辅助队列`pcur`指针不断向后移动

使用calloc申请的空间

* `(StructName *)calloc(NumOfElement,SizeOfElement)`
* 申请的空间大小是2个参数的大小直接相乘
* 会对对空间进行初始化，**赋值为0(NULL)**
* 这里使用可以直接对所有树中的二叉树进行初始化，不用在每次申请完成后

~~~cpp
#ifndef FUNCTION_H  
#define FUNCTION_H  
 
#include <stdio.h>  
#include <stdlib.h>  
typedef char BiElemType;  
typedef struct BiTNode{  
    BiElemType data;  
    struct BiTNode *lchild, *rchild;  
}BiTNode, *BiTree;  
//tag结构体是辅助队列使用的
typedef struct tag  
{  
    BiTree p;  //树的某一个结点的地址值
    struct tag *pnext;  
}tag_t, *ptag_t;  
  
#endif //FUNCTION_H
~~~

~~~cpp
#include "function.h"  
int main()  
{  
    BiTree pnew;//用来指向新申请的树结点  
    BiTree tree=NULL;//tree指向树根的，代表树  
    BiElemType data;//char data;
    ptag_t phead=NULL,ptail=NULL,list_pnew=NULL,pcur;  
    while (scanf("%c", &data))  
    {  
        if (data == '\n')  
        {  
            break;  
        }  
        //calloc申请的空间大小是2个参数的大小直接相乘，并对空间进行初始化，赋值为0(NULL)  
        pnew = (BiTree)calloc(1,sizeof(BiTNode));  
        pnew->data = data;  
        list_pnew = (ptag_t)calloc(1,sizeof(tag_t));  
        list_pnew->p = pnew;  
        //如果是树的第一个结点  
        if (tree == NULL)  
        {  
            tree = pnew;  
            phead = list_pnew;//第一个结点既是队列头，也是队列尾  
            ptail = list_pnew;  
            pcur = list_pnew;//pcur要指向要进入树的父亲元素  
        }else  
        {  
            //先让元素入列  
            ptail->pnext = list_pnew;  
            ptail = list_pnew;  
            //把接下来的结点放入树中  
            if (pcur->p->lchild == NULL)  
            {  
                pcur->p->lchild = pnew;  
            }else if (pcur->p->rchild == NULL)  
            {  
                pcur->p->rchild = pnew;  
                pcur = pcur->pnext;//放入右节点后，当前结点已满，pcur指向下一个结点  
            }  
        }  
    }  
  
    return 0;  
}
~~~

### 13.2.4 二叉树的遍历

* 前序遍历（先序遍历，深度优先遍历）：递归，先打印自身，后打印左子树，再打印右子树
* 中序遍历：递归，先打印左子树，后打印当前结点，再打印右子树
* 后序遍历：递归，先打印左子树，后打印右子树，最后打印当前节点
* 层次遍历（广度优先遍历）：使用辅助队列，借助

前序遍历实例（使用13.2.3的建树代码）

~~~cpp
void PreOrder(BiTree p)  
{  
  
    if (p!=NULL)  
    {  
        printf("%c", p->data);  
        PreOrder(p->lchild);//打印左子树  
        PreOrder(p->rchild);//打印右子树  
    }  
}  
~~~

中序遍历实例（使用13.2.3的建树代码）

~~~cpp
void InOrder(BiTree p)  
{  
    if (p!=NULL)  
    {  
        InOrder(p->lchild);//打印左子树  
        printf("%c", p->data);  
        InOrder(p->rchild);//打印右子树  
    }  
}  
~~~

后序遍历实例（使用13.2.3的建树代码）

~~~cpp
void PostOrder(BiTree p)  
{  
    if (p!=NULL)  
    {  
        PostOrder(p->lchild);//打印左子树  
        PostOrder(p->rchild);//打印右子树  
        printf("%c", p->data);  
    }  
}
~~~

层次遍历，广度优先遍历实例（`function.h`，`queue.cpp`，`main.cpp`）

~~~cpp
//function.h
#ifndef FUNCTION_H  
#define FUNCTION_H  
  
#include <stdio.h>  
#include <stdlib.h>  
  
typedef char BiElemType;  
  
typedef struct BiTNode{  
    BiElemType data;  
    struct BiTNode *lchild, *rchild;  
}BiTNode, *BiTree;  
  
//tag结构体是辅助队列使用的  
typedef struct tag  
{  
    BiTree p;  //树的某一个结点的地址值  
    struct tag *pnext;  
}tag_t, *ptag_t;  
  
//队列的链式存储的结构体  
typedef BiTree ElemType;  
  
typedef struct LinkNode{  
    ElemType data;  
    struct LinkNode *next;  
}LinkNode;  
typedef struct{  
    LinkNode *front, *rear ;//链表头，链表尾  
}LinkQueue ;//先进先出  
  
void InitQueue(LinkQueue &);  
bool IsEmpty(LinkQueue q);  
void EnQueue (LinkQueue &Q, ElemType x);  
bool DeQueue (LinkQueue &Q, ElemType &x);  
  
  
#endif //FUNCTION_H
~~~

~~~cpp
//queue.cpp
#include "function.h"  
//初始化队列  
void InitQueue(LinkQueue &Q)  
{  
    Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));//头和尾指向同一个结点  
    Q.front->next=NULL;//头结点的 next 指针为 NULL}  
//判断队列是否为空  
bool IsEmpty(LinkQueue Q)  
{  
    return Q.front==Q.rear;  
}  
//入队,尾部插入法  
void EnQueue(LinkQueue &Q,ElemType x)  
{  
    LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));  
    s->data=x;s->next=NULL;  
    Q.rear->next=s;//rear 始终指向尾部  
    Q.rear=s;  
}  
//出队,头部删除法  
bool DeQueue(LinkQueue &Q,ElemType &x)  
{  
    if(Q.front==Q.rear)  
    {  
        return false;//队列为空  
    }  
    LinkNode *p=Q.front->next;//头结点什么都没存，所以头结点的下一个节点才有数据  
    x=p->data;  
    Q.front->next=p->next;//断链  
    if(Q.rear==p)//删除的是最后一个元素  
    {  
        Q.rear=Q.front;//队列置为空  
    }  
    free(p);  
    return true;  
}
~~~

~~~cpp
//main.cpp
#include "function.h"  
//前序遍历
void PreOrder(BiTree p)  
{  
  
    if (p!=NULL)  
    {  
        printf("%c", p->data);  
        PreOrder(p->lchild);//打印左子树  
        PreOrder(p->rchild);//打印右子树  
    }  
}  
//中序遍历
void InOrder(BiTree p)  
{  
    if (p!=NULL)  
    {  
        InOrder(p->lchild);//打印左子树  
        printf("%c", p->data);  
        InOrder(p->rchild);//打印右子树  
    }  
}  
//后序遍历
void PostOrder(BiTree p)  
{  
    if (p!=NULL)  
    {  
        PostOrder(p->lchild);//打印左子树  
        PostOrder(p->rchild);//打印右子树  
        printf("%c", p->data);  
    }  
}  
//层次遍历
void LevelOrder(BiTree p)  
{  
    LinkQueue q;  
    InitQueue(q);  
    BiTree pcur;  
    EnQueue(q, p);//树根入队  
    while (!IsEmpty(q))  
    {  
        DeQueue(q, pcur);//出队当前结点并打印  
        putchar(pcur->data);  
        if (pcur->lchild!= NULL)  
        {  
            EnQueue(q, pcur->lchild);//左子树入队  
        }  
        if (pcur->rchild!= NULL)  
        {  
            EnQueue(q, pcur->rchild);//右子树入队  
        }  
    }  
}  
  
int main()  
{  
    BiTree pnew;//用来指向新申请的树结点  
    BiTree tree=NULL;//tree指向树根的，代表树  
    BiElemType data;  
    ptag_t phead=NULL,ptail=NULL,list_pnew=NULL,pcur;  
    while (scanf("%c", &data))  
    {  
        if (data == '\n')  
        {  
            break;  
        }  
        //calloc申请的空间大小是2个参数的大小直接相乘，并对空间进行初始化，赋值为0(NULL)  
        pnew = (BiTree)calloc(1,sizeof(BiTNode));  
        pnew->data = data;  
        list_pnew = (ptag_t)calloc(1,sizeof(tag_t));  
        list_pnew->p = pnew;  
        //如果是树的第一个结点  
        if (tree == NULL)  
        {  
            tree = pnew;  
            phead = list_pnew;//第一个结点既是队列头，也是队列尾  
            ptail = list_pnew;  
            pcur = list_pnew;//pcur要指向要进入树的父亲元素  
        }else  
        {  
            //先让元素入列  
            ptail->pnext = list_pnew;  
            ptail = list_pnew;  
            //把接下来的结点放入树中  
            if (pcur->p->lchild == NULL)  
            {  
                pcur->p->lchild = pnew;  
            }else if (pcur->p->rchild == NULL)  
            {  
                pcur->p->rchild = pnew;  
                pcur = pcur->pnext;//放入右节点后，当前结点已满，pcur指向下一个结点  
            }  
        }  
    }  
    //先序遍历  
    PreOrder(tree);  
    printf("\n");  
    //中序遍历  
    InOrder(tree);  
    printf("\n");  
    //后序遍历  
    PostOrder(tree);  
    printf("\n");  
    //层次遍历  
    LevelOrder(tree);  
    printf("\n");  
    return 0;  
}
~~~
## 13.3 二叉树考研真题实战

### 13.3.1 真题实例

![二叉树408真题](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/14.png)

### 13.3.2 题目分析解题

* 树的带权路径长度(Weighted Path Length of Tree（WPL）：每个叶子结点的深度与权值之积的**总和**
* 叶子结点：没有子结点的结点（`Lchild`和`Rchild`均为空），叶子结点的深度并不相同
* 深度：从根到结点的唯一路径长，root结点的深度为0
* 高度：从结点到一片树叶的最长路径长，所有树叶的高度为0
* 结点的层次：规定root结点在1层，其它任一结点的层数是其父结点的层数加1  
* 树的深度：树中所有结点中的**最大层次**是这棵树的深度
* 权值：结点赋给一个有着某种含义的数值
* 使用较为简单的先序遍历来定义二叉树，添加`static变量`或全局变量记录`wpl`，把每个结点的深度作为一个递归的参数来传递
	1. 若该结点是叶子结点，那么变量 wpl 加上该结点的深度与权值之积
	2. 若该结点非叶子结点，那么若左子树不为空，对左子树调用递归算法，若右子树不为空，对右子树调用递归算法，深度参数均为本结点的深度参数加一
* 最后返回计算出的 wpl 即可。
### 13.3.3 题目代码实现

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
  
typedef int BiElemType;  
  
typedef struct BiTNode{  
    BiElemType weight;//直接拿ASCII来计算即可  
    struct BiTNode *left, *right;  
}BiTNode, *BiTree;  
  
//tag结构体是辅助队列使用的  
typedef struct tag  
{  
    BiTree p;  //树的某一个结点的地址值  
    struct tag *pnext;  
}tag_t, *ptag_t;  
  
//队列的链式存储的结构体  
typedef BiTree ElemType;  
  
typedef struct LinkNode{  
    ElemType data;  
    struct LinkNode *next;  
}LinkNode;  
typedef struct{  
    LinkNode *front, *rear ;//链表头，链表尾  
}LinkQueue ;//先进先出  
  
//前序遍历  
// int wpl = 0;//全局变量，用来计算WPL  
int PreOrder(BiTree p,int deep)  
{  
    static int wpl = 0;  
    if (p!=NULL)  
    {  
        // printf("element is %c--leave is %d \n", p->weight,deep);  
        if (p->left==NULL && p->right==NULL)  
        {  
            wpl = wpl + p->weight*deep;//不是叶子结点的时候不需要算  
        }  
        PreOrder(p->left,deep+1);//打印左子树  
        PreOrder(p->right,deep+1);//打印右子树  
    }  
    return wpl;  
}  
  
  
int main()  
{  
    BiTree pnew;//用来指向新申请的树结点  
    BiTree tree=NULL;//tree指向树根的，代表树  
    BiElemType data;  
    ptag_t phead=NULL,ptail=NULL,list_pnew=NULL,pcur;  
    while (scanf("%c", &data))  
    {  
        if (data == '\n')  
        {  
            break;  
        }  
        //calloc申请的空间大小是2个参数的大小直接相乘，并对空间进行初始化，赋值为0(NULL)  
        pnew = (BiTree)calloc(1,sizeof(BiTNode));  
        pnew->weight = data;  
        list_pnew = (ptag_t)calloc(1,sizeof(tag_t));  
        list_pnew->p = pnew;  
        //如果是树的第一个结点  
        if (tree == NULL)  
        {  
            tree = pnew;  
            phead = list_pnew;//第一个结点既是队列头，也是队列尾  
            ptail = list_pnew;  
            pcur = list_pnew;//pcur要指向要进入树的父亲元素  
        }else  
        {  
            //先让元素入列  
            ptail->pnext = list_pnew;  
            ptail = list_pnew;  
            //把接下来的结点放入树中  
            if (pcur->p->left == NULL)  
            {  
                pcur->p->left = pnew;  
            }else if (pcur->p->right == NULL)  
            {  
                pcur->p->right = pnew;  
                pcur = pcur->pnext;//放入右节点后，当前结点已满，pcur指向下一个结点  
            }  
        }  
    }  
    // PreOrder(tree,1);  
    // // printf("wpl = %d\n",wpl);    printf("wpl = %d\n",PreOrder(tree,1));  
    return 0;  
}
~~~

## 13.4 二叉排序树

### 13.4.1 二叉排序树

二叉排序树（二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树:

1. 若左子树非空，则左子树上所有结点的值均小于根结点的值
2. 若右子树非空，则右子树上所有结点的值均大于根结点的值
3. 左、右子树也分别是一棵二叉排序树

* 二叉排序树的最高查找次数是树的高度
* 二叉排序树使用中序遍历的结果正是从小到大的排序顺序

### 13.4.2 二叉排序树的建树与查找

**非递归**的方式建立二叉排序树，也可以使用递归的方法（下方代码以非递归方式书写）

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
  
typedef int KeyType;  
  
typedef struct BSTNode{  
    KeyType Key;  
    struct BSTNode *lchild, *rchild;  
}BSTNode, *BiTree;  
//非递归的创建二叉排序树，成功返回0，失败返回-1  
int BST_Insert(BiTree &T, KeyType k)  
{  
    BiTree TreeNew = (BiTree)calloc(1,sizeof(BSTNode));//结点申请空间并初始化  
    TreeNew->Key = k;//把值放入  
    if(T == NULL)//数为空，把结点作为树的根节点  
    {  
        T=TreeNew;  
        return 0;  
    }  
    BiTree p = T,p_parent=NULL;//p用来遍历树（查找树）  
    while(p)  
    {  
        p_parent = p;//存储p的上一个结点（p的父亲）  
        if(k < p->Key)//如果树的结点值小于k，k应该在树的右边  
        {  
            p = p->lchild;  
        }else if(k > p->Key)//如果树的结点值大于k，k应该在树的左边  
        {  
            p = p->rchild;  
        }else  
        {  
            return -1;//相等的元素不可以放入查找树，考研没考过  
        }  
    }  
    //接下来要判断父亲的左边还是右边  
    if(k < p_parent->Key)//放父亲的左边  
    {  
        p_parent->lchild = TreeNew;  
    }else if(k > p_parent->Key)//放父亲右边  
    {  
        p_parent->rchild = TreeNew;  
    }  
    return 0;  
}  
//树中不放入重复的元素  
void Creat_BST(BiTree &T, KeyType*  str, int len)  
{  
    int i = 0;  
    for (i = 0; i < len; i++)  
    {  
        BST_Insert(T,str[i]);  
    }  
}  
//中序遍历  
void InOrder(BiTree p)  
{  
    if (p!=NULL)  
    {  
        InOrder(p->lchild);//打印左子树  
        printf("%d ", p->Key);  
        InOrder(p->rchild);//打印右子树  
    }  
}  
//查找结点值并放回父亲结点元素  
BiTree BST_Search(BiTree T, KeyType k, BiTree &p)  
{  
    p = NULL;  
    while(T!=NULL && k!=T->Key)  
    {  
        p = T;  
        if(k < T->Key)  
        {  
            T = T->lchild;  
        }else if(k > T->Key)  
        {  
            T = T->rchild;  
        }  
    }  
    return T;  
}  
  
  
//二叉排序树新建，中序遍历，查找  
int main()  
{  
    BiTree T = NULL;//树根  
  
    KeyType str[7]={54,20,66,40,28,79,58};//要插入的元素  
    Creat_BST(T,str,7);  
    InOrder(T); //中序遍历二叉排序树是由小到大排序  
    printf("\n");  
    BiTree parent = NULL;//存储父亲结点的地址值  
    BiTree search = BST_Search(T,40,parent);//查找结点值并放回父亲结点元素  
    if(search)  
    {  
        printf("Found key %d,key's parent is %d\n",search->Key,parent->Key);  
    }else  
    {  
        printf("Key not found\n");//没有找到search返回的是NULL  
    }  
    return 0;  
}
//输出：
//20 28 40 54 58 66 79
//非递归的方式建立二叉排序树
~~~

### 13.4.3 二叉顺序树的删除

* 使用递归的思想来做
* 下方代码使用的左子树的最大值，但也可以换成右子树的最小值来做题

~~~cpp
//非递归的方式建立二叉排序树  
#include <stdio.h>  
#include <stdlib.h>  
  
typedef int KeyType;  
  
typedef struct BSTNode{  
    KeyType Key;  
    struct BSTNode *lchild, *rchild;  
}BSTNode, *BiTree;  
//非递归的创建二叉排序树，成功返回0，失败返回-1  
int BST_Insert(BiTree &T, KeyType k)  
{  
    BiTree TreeNew = (BiTree)calloc(1,sizeof(BSTNode));//结点申请空间并初始化  
    TreeNew->Key = k;//把值放入  
    if(T == NULL)//数为空，把结点作为树的根节点  
    {  
        T=TreeNew;  
        return 0;  
    }  
    BiTree p = T,p_parent=NULL;//p用来遍历树（查找树）  
    while(p)  
    {  
        p_parent = p;//存储p的上一个结点（p的父亲）  
        if(k < p->Key)//如果树的结点值小于k，k应该在树的右边  
        {  
            p = p->lchild;  
        }else if(k > p->Key)//如果树的结点值大于k，k应该在树的左边  
        {  
            p = p->rchild;  
        }else  
        {  
            return -1;//相等的元素不可以放入查找树，考研没考过  
        }  
    }  
    //接下来要判断父亲的左边还是右边  
    if(k < p_parent->Key)//放父亲的左边  
    {  
        p_parent->lchild = TreeNew;  
    }else if(k > p_parent->Key)//放父亲右边  
    {  
        p_parent->rchild = TreeNew;  
    }  
    return 0;  
}  
//创建树，树中不放入重复的元素  
void Creat_BST(BiTree &T, KeyType*  str, int len)  
{  
    int i = 0;  
    for (i = 0; i < len; i++)  
    {  
        BST_Insert(T,str[i]);  
    }  
}  
//中序遍历  
void InOrder(BiTree p)  
{  
    if (p!=NULL)  
    {  
        InOrder(p->lchild);//打印左子树  
        printf("%d ", p->Key);  
        InOrder(p->rchild);//打印右子树  
    }  
}  
  
//这个书上没有二叉顺序树的删除代码，考大题没那么高  
void DeleteNode(BiTree &root, KeyType x)  
{  
    if (root == NULL)  
    {  
        return;  
    }  
    if (root->Key>x)//当前结点大于被删除结点，往左子树走  
    {  
        DeleteNode(root->lchild,x);  
    }else if(root->Key<x)//当前结点小于被删除结点，往右子树走  
    {  
        DeleteNode(root->rchild,x);  
    }else//当前结点等于被删除结点root->key==x  
    {  
        if(root->lchild==NULL)//结点的左子树为空，结点的右子树直接代替被删除结点  
        {  
            BiTree temp = root;//用临时的存着的目的是一会要free  
            root = root->rchild;  
            free(temp);  
        }else if(root->rchild==NULL)//结点的右子树为空，结点的左子树直接代替被删除结点  
        {  
            BiTree temp = root;//临时指针  
            root = root->lchild;  
            free(temp);  
        }else//两边都不为空，找左子树的最大值或者右子树的最小值来代替被删除结点  
        {  
            BiTree temp = root->lchild;  
            while(temp->rchild!=NULL)//向右找到最大的  
            {  
                temp = temp->rchild;  
            }  
            root->Key = temp->Key;//把temp对应的值替换到要删除的值  
            DeleteNode(root->lchild,temp->Key);//在左子树中找到temp并删除  
        }  
    }  
}  
  
//二叉排序树新建，删除结点  
int main()  
{  
    BiTree T = NULL;//树根  
  
    KeyType str[7]={54,20,66,40,28,79,58};//要插入的元素  
    Creat_BST(T,str,7);  
    InOrder(T); //中序遍历二叉排序树是由小到大排序  
    printf("\n");  
    DeleteNode(T,40);  
    InOrder(T);  
    printf("\n");  
    return 0;  
}
~~~


## 13.5 二叉排序树考研真题实战


### 13.5.1 真题实例

![二叉排序树408真题](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/15.png)


### 13.5.2 题目分析解题


* 在数组中元素个数为偶数的时候，中位数判定为前一个数，较小的一个作为中位数
* 不能使用额外的空间，就在2个数组上修改
* 分别求出序列A和B的中位数，设为a和b，求序列A和B的中位数过程如下:
	1. 若a=b，则a或b即为所求中位数，算法结束
	2. 若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半,要求舍弃的长度相等
	3. 若a>b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求舍弃的长度相等
	4. 在保留的两个升序序列中，重复过程1、2、3，直到两个序列中均只含一个元素时为止，较小者即为所求的中位数
 * 奇数个的时候只能删除中位数之前的数
 * 偶数个的时候，舍弃中间点以及中间点前的数

### 13.5.3 题目代码实例


~~~cpp
//2011年42题  
#include <stdio.h>  
  
int MidSearch(int *A,int *B,int n)  
{  
    //分别表示序列A和B的首位数、末位数和中位数、s是start，d是end  
    int s1 = 0,d1 = n-1,m1=0,s2 = 0,d2 = n-1,m2=0;  
    //循环判断结束条件是，2个数组均不断删除最后均只能剩余一个元素  
    while(s1!=d1 || s2!=d2)  
    {  
        m1 = (s1 + d1 )/2;  
        m2 = (s2 + d2 )/2;  
        if(A[m1]==B[m2])  
        {  
            return A[m1];//满足情况1，已求得中位数  
        }else if (A[m1]<B[m2])//满足条件2  
        {  
            //这里的奇偶数指的是一半大小的数组的元素个数的奇偶  
            if((s1+d1)%2==0)//若元素个数为奇数，注意这里的数组下标从0开始的  
            {  
                s1=m1;//舍弃A中间点以前的部分  
                d2=m2;//舍弃B中间点以后的部分  
            }else if((s1+d1)%2!=0)//元素个数为偶数  
            {  
                s1=m1+1;//舍弃A中间点及中间点以前的部分,需要+1  
                d2=m2;//舍弃B中间点以后的部分且保留中间点  
            }  
        }else if(A[m1]>B[m2])//满足条件3  
        {  
            if((s1+d1)%2==0)//个数为奇数  
            {  
                d1 = m1;  
                s2 = m2;  
            }else if((s1+d1)%2!=0)//个数为偶数  
            {  
                d1 = m1;  
                s2 = m2+1;  
            }  
        }  
    }  
    return A[s1]<B[s2]?A[s1]:B[s2];//返回2个数组中剩余元素较小的那个  
}  
  
  
int main()  
{  
    int A[] = {11,13,15,17,19};  
    int B[] = {2,4,6,8,20};  
    int mid = MidSearch(A,B,5);//最后一个表示数组的长度  
    printf("mid = %d\n",mid);  
    return 0;  
}
//输出结果
//mid = 11
~~~

## 13.6 堆（特殊的树）

堆(Heap)是计算机科学中的一种**特殊的树状数据结构**。一棵**完全二叉树**，这里采用层次建树法，虽然只用一个**数组存储元素**，但是能将二叉树中任意一个位置的元素对应到数组下标上，将二叉树中每个元素对应到数组下标的这种数据结构称为堆。

* 根结点(rootnode)：堆中最顶端的那个结点，根结点本身没有父结点(parentnode)。

* 最小堆(min heap，小根堆，小顶堆)：给定堆中任意结点P和C若P是C的父结点，则P的值小于等于C的值。父结点的值恒小于等于子结点的值。

* 最大堆(max heap，大根堆，大顶堆)：给定堆中任意结点P和C若P是C的父结点，则P的值大于等于C的值。父结点的值恒大于等于子结点的值。

# 14. 查找

## 14.1 顺序查找

### 14.1.1 顺序查找

* **顺序查找**又称**线性查找**，它对于顺序表和链表都是适用的。
* 对于顺序表，可通过数组下标递增来顺序扫描每个元素
* 对于链表，则通过指针 next 来依次扫描每个元素

###  14.1.2 顺序表的顺序查找实例

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
#include <time.h>  
typedef int ElemType ;  
typedef struct{  
    ElemType* elem;//整型指针  
    int TableLen;//存储动态数组里边元素的个数  
}SSTable;  
  
//顺序查找  
int Search_Seq(SSTable ST,ElemType key)  
{  
    //key存在零号位置，作为哨兵，有了这个，我们在循环时，可以少写一个i>=0的判断  
    ST.elem[0] = key;  
    int i;  
    //从后往前找，找到了就刚好是位置；没找到就是0，c语言的0为假
    for(i=ST.TableLen-1;ST.elem[i]!=key;--i);  
    return i;  
}  
  
//初始化顺序表  
void ST_Init(SSTable &ST,int len)  
{  
    //多申请一个位置，在第0个位置存在哨兵，哨兵的存在并不是必须的  
    ST.TableLen = len+1;  
    //每个元素的大小乘上元素的个数，然后申请空间  
    ST.elem = (ElemType*)malloc(ST.TableLen*sizeof(ElemType));  
  
    //随机数的生成与使用  
    int i;  
    srand(time(NULL));//随机数的生成，不需要掌握  
    for(i=1;i<ST.TableLen;i++)//因为第0个是哨兵，所以从1随机  
    {  
        ST.elem[i] = rand()%100;//模上100，是为了让生成的随机数在0-99之间  
    }  
}  
  
//打印顺序表  
void ST_print(SSTable ST)  
{  
    int i;  
    for(i=1;i<ST.TableLen;i++)  
    {  
        printf("%3d",ST.elem[i]);//直接类似数组名来使用  
    }  
    printf("\n");  
}  
  
  
  
//顺序查找  
int main()  
{  
    SSTable ST;  
    ElemType key;  
    int pos;//存储查询元素的位置  
    ST_Init(ST,10);  
    ST_print(ST);  
    printf("please input search Key:\n");  
    scanf("%d",&key);  
    pos = Search_Seq(ST,key);  
    if(pos)  
    {  
        printf("Key %d is found at position %d\n",key,pos);  
    }else  
    {  
        printf("Key %d not found\n",key);  
    }  
    return 0;  
}
~~~


## 14.2 折半查找

### 14.2.1 折半查找

**折半查找**又称**二分查找**，它**仅适用**于**有序的顺序表**。

折半查找的基本思想
1. 首先将给定值 key 与表中中间位置的元素比较
	* 若相等，则查找成功，返回该元素的存储位置
	* 若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分
	* 例如，在查找表升序排列时，若给定值key大于中间元素，则所查找的元素只可能在后半部分
2. 在缩小的范围内继续进行同样的查找，如此重复,直到找到为止,或确定表中没有所需要查找的元素则查找不成功，返回查找失败的信息。

针对**顺序表有序**，我们使用 qsort 来排序，具体排序算法参考15章排序算法，qsort 的使用方法如下：

~~~cpp
#include <stdlib.h>  
void qsort( void *buf, size_t num, size_t size, int(*compare)(const void *, const void *));
~~~

* buf：要排序数组的起始地址，也可以是指针，申请了一块连续的堆空间
* num：数组中元素的个数
* size：数组中每个元素所占用的空间大小
* compare：比较规则，需要我们传递一个函数名，这个函数由我们自己编写，返回值必须是 int 类型，形参是两个 void 类型指针，这个函数我们编写，但是是qsort 内部调用的，相当于我们**传递一种行为**给 qsort。

> qsort 初试是不会考这个接口的，机试时会用上，或者复试面试可以讲

### 14.2.2 折半查找实例

* 不需要使用哨兵
* 初始化顺序表，随机10个元素
* 输入要查找的元素值，存入变量key中
* 因为函数名存放的是函数的入口地址，所以函数名可以作为参数传递
* 在caompare函数中left指针和right指针是指向数组中的任意2个元素
* 使用qsort进行排序，排序完毕后，打印
* qsort规定，如果left指针指向的值大于right指针指向的值，返回正值；反之返回负值；相等返回0.


~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
#include <time.h>  
typedef int ElemType ;  
typedef struct{  
    ElemType* elem;//整型指针  
    int TableLen;//存储动态数组里边元素的个数  
}SSTable;  
  
//初始化顺序表，进行随机数的生成，折半查找所以没有使用哨兵  
void ST_Init(SSTable &ST,int len)  
{  
    ST.TableLen = len;  
    //每个元素的大小乘上元素的个数，然后申请空间  
    ST.elem = (ElemType*)malloc(ST.TableLen*sizeof(ElemType));  
    //随机数的生成与使用  
    int i;  
    srand(time(NULL));//随机数生成  
    for(i=0;i<ST.TableLen;i++)  
    {  
        ST.elem[i] = rand()%100;//模上100，是为了让生成的随机数在0-99之间  
    }  
}  
  
//打印顺序表  
void ST_print(SSTable ST)  
{  
    int i;  
    for(i=1;i<ST.TableLen;i++)  
    {  
        printf("%3d",ST.elem[i]);//直接类似数组名来使用  
    }  
    printf("\n");  
}  
  
//实现二分查找  
int BinarySearch(SSTable L,ElemType key)  
{  
    int low=0;  
    int high=L.TableLen-1;  
    int mid=0;  
    while(low<=high)  
    {  
        mid=(low+high)/2;  
        if(key>L.elem[mid])  
        {  
            low=mid+1;  
        }else if(key<L.elem[mid])  
        {  
            high=mid-1;  
        }else if(key==L.elem[mid])  
        {  
            return mid;  
        }  
    }  
    return -1;  
}  
//函数名存的是函数的入口地址，所以函数名可以作为参数传递  
//left指针和right指针是指向数组中的任意2个元素  
//qsort规定，如果left指针指向的值大于right指针指向的值，返回正值；反之返回负值；相等返回0.  
int compare(const void *left, const void *right)  
{  
    return *(int *)left - *(int *)right;//从大到小排序  
}  
//顺序查找  
int main()  
{  
    SSTable ST;  
    ST_Init(ST,10);//初始化，随机10个元素  
    qsort(ST.elem,ST.TableLen,sizeof(ElemType),compare);//排序  
    ElemType Key;  
    ST_print(ST);  
    printf("Enter Key:");  
    scanf("%d",&Key);  
    int index = BinarySearch(ST,Key);  
    if(index!=-1)  
    {  
        printf("Find Key %d in position:%d\n",Key,index);  
    }else  
    {  
        printf("Key not found\n");  
    }  
    return 0;  
}
~~~

排序算法
* 交换类排序（冒泡排序，快速排序）
* 插入类排序
* 选择类排序
* 归并类排序

![所有排序算法的时间复杂度空间复杂度稳定性和复杂性汇总](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/16.png)

* 稳定性是指排序前后，相等的元素位置是否会被交换
* 复杂性是指代码编写的难度

# 15. 查找
## 15.1 冒泡排序

### 15.1.1 冒泡排序的原理

冒泡排序的基本思想是：从后往前(或从前往后)两两比较相邻元素的值，(若`A[i-1]>A[j]`)，则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置。关键字最小的元素如气泡一般逐渐往上“漂浮”直至“水面”。下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果是把序列中的最小元素放到了序列的最终位置。最多做n-1趟冒泡就能把所有元素排好序。

![冒泡排序演示](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/17.png)


### 15.1.2 冒泡排序实例

随机生成10个数，先打印一次，再冒泡排序，最后再打印一次

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
#include <time.h>  
#include <string.h>  
typedef int ElemType ;  
typedef struct{  
    ElemType * elem;//整型指针  
    int TableLen;//存储动态数组里边元素的个数  
}SSTable;  
  
void ST_Init(SSTable &ST,int len)  
{  
    ST.TableLen = len;  
    ST.elem = (ElemType*)malloc(ST.TableLen*sizeof(ElemType));  
    int i;  
    srand(time(NULL));  
    for(i=0;i<ST.TableLen;i++)  
    {  
        ST.elem[i] = rand()%100;//生成的随机数在0-99之间  
    }  
}  
//打印数组  
void ST_print(SSTable ST)  
{  
    int i;  
    for(i=0;i<ST.TableLen;i++)  
    {  
        printf("%3d",ST.elem[i]);//直接类似数组名来使用  
    }  
    printf("\n");  
}  
//交换2个元素  
void swap(int &a,int &b)  
{  
    int tmp;  
    tmp=a;  
    a=b;  
    b=tmp;  
}  
//冒泡排序算法  
void BulleSort(ElemType *A,int len)  
{  
    int i,j;  
    bool flag;  
    for(i=0;i<len-1;i++)//i最多访问到n-2  
    {  
        flag = false;//元素是否发生交换的标志  
        for(j=len-1;j>i;j--){//把最小值放在最前面  
            if(A[j-1]>A[j]){  
                swap(A[j-1],A[j]);  
            }  
            flag = true;  
        }  
        if(flag == false)//如果第一趟没有发生交换，则说明已经有序，直接返回  
        {  
            return;  
        }  
    }  
}  
  
int main()  
{  
    SSTable ST;  
    ST_Init(ST,10);  
    //使用固定数组方便调试  
    ElemType A[10]={64,94,95,79,69,84,18,22,12,78};  
    //内存copy接口，当你copy整型数组，或者浮点型时，要用memcopy，不能使用strcopy，初始考到的概率很低  
    memcpy(ST.elem,A,sizeof(A));  
    ST_print(ST);  
    BulleSort(ST.elem,ST.TableLen);  
    ST_print(ST);  
    return 0;  
}
//打印结果
// 94 95 79 69 84 18 22 12 78
// 18 22 64 69 78 79 84 94 95
~~~

### 15.1.3 复杂度分析


时问复杂度：程序实际的运行次数，可以看到内层是`j>i`，外层`i`的值是从`0`到`N-1`，所以程序的总运行次数是`1+2+3+…+(N-1)`，即从`1`一直加到`N-1`，这是等差数列求和，得到的结果是 `N(N-1)/2`，即总计运行了这么多次，忽略了低阶项和高阶项的首项系数，因为时间复杂度为 $0(n^2)$

空间复杂度：因为未使用额外的空间（额外空间必须与输入元素的个数 N相关），所以空间复杂为 $0(1)$。



## 15.2 快速排序

### 15.2.1 快速排序原理

快速排序的核心是**分治思想**：假设我们的目标依然是按从小到大的顺序排列，我们找到数组中的一个分割值，把比分割值小的数都放在数组的左边，把比分割值大的数都放在数组的右边，这样分割值的位置就被确定。数组一分为二，我们只需排前一半数组和后一半数组，复杂度直接减半。采用这种思想不断地进行递归，最终分割得只剩一个元素时，整个序列自然就是有序的。

### 15.2.2 快速排序实例

挖坑法：先把最左边的元素拿出来作为分割值，然后从右边开始找比分割值小的元素，找到后就把这个元素填到左边的坑中，然后左边的坑就变成了新的坑，然后从左边开始找比分割值大的元素，找到后就把这个元素填到右边的坑中，然后右边的坑就变成了新的

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
#include <time.h>  
#include <string.h>  
typedef int ElemType ;  
typedef struct{  
    ElemType * elem;//整型指针  
    int TableLen;//存储动态数组里边元素的个数  
}SSTable;  
  
void ST_Init(SSTable &ST,int len)  
{  
    ST.TableLen = len;  
    ST.elem = (ElemType*)malloc(ST.TableLen*sizeof(ElemType));  
    int i;  
    srand(time(NULL));  
    for(i=0;i<ST.TableLen;i++)  
    {  
        ST.elem[i] = rand()%100;//生成的随机数在0-99之间  
    }  
}  
//打印数组  
void ST_print(SSTable ST)  
{  
    int i;  
    for(i=0;i<ST.TableLen;i++)  
    {  
        printf("%3d",ST.elem[i]);//直接类似数组名来使用  
    }  
    printf("\n");  
}  
//分割函数（快排的核心）  
//挖坑法（需要熟练掌握）  
int partition(ElemType *A,int low,int high)  
{  
    ElemType pivot = A[low];//拿最左边的作为分割值，并存储下来  
    while(low<high)  
    {  
        while(low<high && A[high]>=pivot)//从后往前遍历找到一个比分隔值小的  
        {  
            high--;  
        }  
        A[low] = A[high];//把比分隔值小的元素，放到A[low]的位置  
        while (low<high && A[low]<=pivot)//从前往后遍历，找到一个比分隔值大的  
        {  
            low++;  
        }  
        A[high] = A[low];  
    }  
    A[low] = pivot;//分隔值放在中间位置，刚好左边都比他小，右边都比他大  
    return low;//返回分割值所在的下标  
}  
//快速排序算法  
void QuickSort(ElemType *A,int low,int high)  
{  
    if(low<high)  
    {  
        int pivot_pos = partition(A,low,high);//存储分隔值的位置  
        QuickSort(A,low,pivot_pos-1);//前一半继续递归排序  
        QuickSort(A,pivot_pos+1,high);//后一半继续递归排序  
    }  
  
}  
  
int main()  
{  
    SSTable ST;  
    ST_Init(ST,10);  
    //使用固定数组方便调试  
    ElemType A[10]={64,94,95,79,64,84,18,22,12,78};  
    //内存copy接口，当你copy整型数组，或者浮点型时，要用memcopy，不能使用strcopy，初始考到的概率很低  
    memcpy(ST.elem,A,sizeof(A));  
    ST_print(ST);  
    QuickSort(ST.elem,0,9);//0和9就是第一个和最后一个元素的下标  
    ST_print(ST);  
    return 0;  
}
~~~

### 15.2.3 复杂度分析

时间复杂度：最好时间复杂度$O(n\log_{2}{n})$，最差时间复杂度$O(n^2)$

空间复杂度：$O(\log_{2}{n})$，因为递归的次数是$\log_{2}{n}$，而么此递归的形参都是要占用空间的


## 15.3 插入排序

插入排序分为：直接插入排序，折半插入排序，希尔排序

### 15.3.1 直接插入排序原理


![插入排序过程](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/18.png)

### 15.3.2 直接插入排序实例

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
#include <time.h>  
#include <string.h>  
typedef int ElemType ;  
typedef struct{  
    ElemType * elem;//整型指针  
    int TableLen;//存储动态数组里边元素的个数  
}SSTable;  
  
void ST_Init(SSTable &ST,int len)  
{  
    ST.TableLen = len;  
    ST.elem = (ElemType*)malloc(ST.TableLen*sizeof(ElemType));  
    int i;  
    srand(time(NULL));  
    for(i=0;i<ST.TableLen;i++)  
    {  
        ST.elem[i] = rand()%100;//生成的随机数在0-99之间  
    }  
}  
//打印数组  
void ST_print(SSTable ST)  
{  
    int i;  
    for(i=0;i<ST.TableLen;i++)  
    {  
        printf("%3d",ST.elem[i]);//直接类似数组名来使用  
    }  
    printf("\n");  
}  
  
void InsertSort(ElemType *A,int n)  
{  
    int i,j,insertVal;  
    for(i=1;i<n;i++)//外层控制要插入的数  
    {  
        insertVal = A[i];//保存要插入的数  
        for(j=i-1;j>=0&&A[j]>insertVal;j--)//内层控制要插入的数  
        {  
            A[j+1] = A[j];//后移  
        }  
        A[j+1] = insertVal;  
    }  
}  
  
int main()  
{  
    SSTable ST;  
    ST_Init(ST,10);  
    //使用固定数组方便调试  
    ElemType A[10]={64,94,95,79,64,84,18,22,12,78};  
    //内存copy接口，当你copy整型数组，或者浮点型时，要用memcopy，不能使用strcopy，初始考到的概率很低  
    memcpy(ST.elem,A,sizeof(A));  
    ST_print(ST);  
    InsertSort(ST.elem,10);  
    ST_print(ST);  
    return 0;  
}
~~~

### 15.3.3 复杂度分析

随着有序序列的不断增加，插入排序比较的次数也会增加，插入排序的执行次数也是从1加到N-1，总运行次数为(N-1)/2，时间复杂度依然为$O(n^2)$。如果数组本身有序，那么就是最好的时间复杂度 0(n)。

因为未使用额外的空间(额外空间必须与输入元素的个数 N相关)，所以空间复杂为 0(1)

## 15.4 选择排序

### 15.4 选择排序原理

简单选择排序≠选择排序，但是考研考试一般都把简单选择排序写成选择排序

假设排序表为 `L[1…n]`，第i趟排序即从`L[i…n]`中选择关键字最小的元素与 L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序。

![选择排序的过程](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/19.png)

### 15.4 选择排序实例

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
#include <time.h>  
#include <string.h>  
typedef int ElemType ;  
typedef struct{  
    ElemType * elem;//整型指针  
    int TableLen;//存储动态数组里边元素的个数  
}SSTable;  
//数组初始化并填充随机数  
void ST_Init(SSTable &ST,int len)  
{  
    ST.TableLen = len;  
    ST.elem = (ElemType*)malloc(ST.TableLen*sizeof(ElemType));  
    int i;  
    srand(time(NULL));  
    for(i=0;i<ST.TableLen;i++)  
    {  
        ST.elem[i] = rand()%100;//生成的随机数在0-99之间  
    }  
}  
//打印数组  
void ST_print(SSTable ST)  
{  
    int i;  
    for(i=0;i<ST.TableLen;i++)  
    {  
        printf("%3d",ST.elem[i]);//直接类似数组名来使用  
    }  
    printf("\n");  
}  
//选择排序  
void  SelectSort(ElemType A[],int len)  
{  
    int i,j,min=0;  
    ElemType temp;  
    for(i=0;i<len-1;i++)//最后一个在循环结束的时候一定是最大的，所以循环到len-1  
    {  
        min = i;  
        for(j=i+1;j<len;j++)  
        {  
            if(A[j]<A[min])//修改判断条件就可改为从大到小排序  
            {  
                min = j;  
            }  
        }  
        if(min!=i){  
            temp = A[i];  
            A[i] = A[min];  
            A[min] = temp;  
        }  
    }  
}  
  
  
int main()  
{  
    SSTable ST;  
    ST_Init(ST,10);  
    //使用固定数组方便调试  
    ElemType A[10]={64,94,95,79,64,84,18,22,12,78};  
    //内存copy接口，当你copy整型数组，或者浮点型时，要用memcopy，不能使用strcopy，初始考到的概率很低  
    memcpy(ST.elem,A,sizeof(A));  
    ST_print(ST);  
    SelectSort(ST.elem,10);  
    ST_print(ST);  
    return 0;  
}
~~~


### 15.4.3 复杂度分析

选择排序虽然减少了交换次数，但是循环比较的次数依然和冒泡排序的数量是一样的，都是从 `1`加到 `N-1`，总运行次数为`N(N-1)/2`。我们忽略循环内语句的数量，因为我们在计算时间复杂度时，主要考虑与N有关的循环，如果循环内交换得多，例如有5条语句，那么最终得到的无非是$5n^2$;循环内交换得少，例如有2条语句，那么得到的就是$2n^2$，但是时间复杂度计算是忽略首项系数的，因此最终还是 `0(n)`。因此，选择排序的时间复杂度依然为 $0(n^2)$。因为未使用额外的空间（额外空间必须与输入元素的个数 N 相关），所以空间复杂为 `O(1)`。另外考研初试问时间复杂度，直接书写结果即可。


## 15.5 堆排序

堆排序是选择排序的一种。



### 15.5.1 堆排序原理


堆的最后一个父亲元素的下标是`N/2-1`，N为数组的元素个数。父节点下标为`dad`，那么对应的左子节点的下标为`2*dad+1`。从最后一个子树开始，调整每一个子树为父节点最大，就成为了大根堆。注意并未根据2个子树的大小做出左右位置限制。当根节点的值最大时，将其与数组的最后元素交换，循环往复调整为大根堆，直到变为有序。


### 15.5.2 堆排序实例

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
#include <time.h>  
#include <string.h>  
typedef int ElemType ;  
typedef struct{  
    ElemType * elem;//整型指针  
    int TableLen;//存储动态数组里边元素的个数  
}SSTable;  
//数组初始化并填充随机数  
void ST_Init(SSTable &ST,int len)  
{  
    ST.TableLen = len;  
    ST.elem = (ElemType*)malloc(ST.TableLen*sizeof(ElemType));  
    int i;  
    srand(time(NULL));  
    for(i=0;i<ST.TableLen;i++)  
    {  
        ST.elem[i] = rand()%100;//生成的随机数在0-99之间  
    }  
}  
//交换位置  
void swap(ElemType &a,ElemType &b)  
{  
    ElemType tmp;  
    tmp=a;  
    a=b;  
    b=tmp;  
}  
//打印数组  
void ST_print(SSTable ST)  
{  
    int i;  
    for(i=0;i<ST.TableLen;i++)  
    {  
        printf("%3d",ST.elem[i]);//直接类似数组名来使用  
    }  
    printf("\n");  
}  
//把某个子树调整为大根堆  
void AdjustDown(ElemType A[],int k,int len)  
{  
    int dad=k;//父亲的下标  
    int son=2*dad+1;//左孩子的下标  
    while(son<=len)//当son小于len时，说明有孩子，否则没有孩子，就不用调整了  
    {  
        if(A[son]<A[son+1]&&son+1<=len)//右孩子存在才可以判断，否则会数组越界  
        {  
            son++;//拿右孩子和父亲比  
        }  
        if(A[son]>A[dad])//如果孩子比父亲大，就交换位置  
        {  
            swap(A[dad],A[son]);//交换父亲和孩子的位置  
            dad=son;//son重新作为dad，去判断是否符合大根堆，子树的子树可能需要再被调整  
            son=2*dad+1;  
        }else  
        {  
            break;  
        }  
    }  
}  
//堆排序，不需要使用递归即可实现  
void  HeapSort(ElemType A[],int len)  
{  
    int i;  
    //把堆，调整为大根堆  
    for(i=len/2-1;i>=0;i--)//len/2-1是最后一个非叶子节点的下标,即最后一个父亲元素  
    {  
        AdjustDown(A,i,len);//树，需要调整的子树即父亲元素的下标，数组的长度  
    }  
    swap(A[0],A[len]);//交换堆顶和最后一个元素的位置  
    for(i=len-1;i>1;i--)//i代表剩余的无序数的数组的长度  
    {  
        AdjustDown(A,0,i);//调整剩余元素作为大根堆  
        swap(A[0],A[i]);//交换堆顶和最后一个元素的位置  
    }  
}  
  
  
int main()  
{  
    SSTable ST;  
    ST_Init(ST,10);  
    //使用固定数组方便调试  
    ElemType A[10]={3,87,2,93,78,56,61,38,12,40};  
    //内存copy接口，当你copy整型数组，或者浮点型时，要用memcopy，不能使用strcopy，初始考到的概率很低  
    memcpy(ST.elem,A,sizeof(A));  
    ST_print(ST);  
    //注意有些书上0号元素不参与排序，考研考的都是0号元素参与排序  
    HeapSort(ST.elem,9);//最后一个元素的下标为9  
    ST_print(ST);  
    return 0;  
}
~~~

### 15.5.3 复杂度分析

`AdjustDown`函数的循环次数是 $\log_{2}{n}$, `HeapSort`函数的第一个 for 循环了`n/2`次，第二个 for循环了`n`次，总计次数是 $\frac{3}{2}n\log_{2}{n}$次，因此时间复杂度是$O(n\log_{2}{n})$。

堆排最好、最坏、平均时问复杂度都是$O(n\log_{2}{n})$。

堆排的空间复杂度是`O(1)`，因为没有使用与n相关的额外空间。

## 15.6 归并排序


### 15.6.1  归并排序原理


![归并排序算法](https://raw.githubusercontent.com/pqqqYa/pqqqYa.github.io/main/img/post/2024-10-02/20.png)

考研一般只会考两两归并排序

### 15.6.2  归并排序实例

~~~cpp
#include <stdio.h>  
#define N 7  
typedef int ElemType ;  
//打印数组  
void print(ElemType A[])  
{  
    int i;  
    for(i=0;i<N;i++)  
    {  
        printf("%3d",A[i]);//直接类似数组名来使用  
    }  
    printf("\n");  
}  
//合并2个有序数组  
void Merge(ElemType A[],int low,int mid,int high)  
{  
    static ElemType B[N];//加static的目的是无论递归调用多少次，都只有一个B[N]  
    int i=0,j=0,k=0;  
    for(i=low;i<=high;i++)//将A中所有元素复制到B中  
    {  
        B[i]=A[i];  
    }  
    k=low;//K用来控制A的下标，负责放置元素  
    for(i=low,j=mid+1;i<=mid&&j<=high;)  
    {  
        if(B[i]<B[j])  
        {  
            A[k]=B[i];  
            i++;  
            k++;  
        }else  
        {  
            A[k]=B[j];  
            j++;  
            k++;  
        }  
    }  
    //把有一个有序数组的剩余元素放入A  
    while(i<=mid)  
    {  
        A[k]=B[i];  
        i++;  
        k++;  
    }  
    while(j<=high)  
    {  
        A[k]=B[j];  
        j++;  
        k++;  
    }  
}  
  
  
//归并排序(递归写法)  
void MergeSort(ElemType A[],int low,int high)//递归分割  
{  
    if(low<high)  
    {  
        int mid=(low+high)/2;  
        MergeSort(A,low,mid);//排序好前一半  
        MergeSort(A,mid+1,high);//排序好后一半  
        Merge(A,low,mid,high);//将2个排序好的数组合并  
    }  
}  
  
int main()  
{  
    ElemType A[N]={49,38,65,97,76,13,27};  
    print(A);  
    MergeSort(A,0,6);  
    print(A);  
    return 0;  
}
~~~

### 15.6.3 复杂度分析

`MergeSort`函数的递归次数是$\log_{2}{n}$，`Merge`函数的循环了`n`次，因此时间复杂度是$O(n\log_{2}{n})$，归并排序最好、最坏、平均时间复杂度都是$O(n\log_{2}{n})$。

归并排序的空间复杂度是`0(n)`，因为使用了数组B进行辅助，所以它的大小与A一样，占用n个元素的空间。